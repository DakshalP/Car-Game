<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>基于 WebGL 的赛车游戏</title>
  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/THREEx.KeyboardState.js"></script>
  <style>
    body {
      padding: 0;
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin:0 auto;
    }
  </style>
</head>
<body>
<div id="ThreeJS" style="z-index: 2;"></div>

<script>
  // 定义全局变量
  var container, scene, camera, renderer, controls;
  var keyboard = new THREEx.KeyboardState();
  var clock = new THREE.Clock;
  
  var movingCube;
  var collideMeshList = [];
  var cubes = [];
  var crash = false;
  var id = 0;
  var score = 0;
  var crashId = " ";
  var lastCrashId = " ";
  
  init();
  animate();
  
  function init() {
    // Scene
    scene = new THREE.Scene();
    // Camera
    var screenWidth = window.innerWidth;
    var screenHeight = window.innerHeight;
    camera = new THREE.PerspectiveCamera(45, screenWidth/screenHeight, 0.1, 5000);
    camera.position.set(0, 150, 600);
    
    // renderer
    renderer = new THREE.WebGLRenderer({
      antialias: true,
      logarithmicDepthBuffer: true
    });
    
    // 天的颜色
    renderer.setClearColor(new THREE.Color(0x69c6d0));
    renderer.setSize(screenWidth, screenHeight);
    renderer.shadowMap.enabled = true;
    
    container = document.getElementById("ThreeJS");
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    
    // 加入地面
    var floorMaterial = new THREE.MeshBasicMaterial({
      color: 0x222222,
      side: THREE.DoubleSide
    });
    var floorGeometry = new THREE.PlaneGeometry(600, 10000, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
  
    // II. Lighting
    var ambientLight = new THREE.AmbientLight(0xffffff);
    ambientLight.name = "Ambient Light";
    scene.add(ambientLight);
    
    var hemiLight = new THREE.HemisphereLight(0x0044ff, 0xffffff, 0.5);
    hemiLight.name = "Hemisphere Light";
    hemiLight.position.set(0,5,0);
    scene.add(hemiLight);
  
    
    // 加入控制的cube
    var cubeGeometry = new THREE.CubeGeometry(50, 50, 50, 10, 10, 10);
    var wireMaterial = new THREE.MeshBasicMaterial({
      color: 0xfff000
    });
    movingCube = new THREE.Mesh(cubeGeometry, wireMaterial);
    movingCube.position.set(0, 25, 0);
    scene.add(movingCube);
  }
  
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    update();
  }
  
  function update() {
    controls.update();
    var delta = clock.getDelta();
    var moveDistance = 200 * delta;
    var rotateAngle = Math.PI / 2 * delta;
    if (keyboard.pressed("left")) {
      if (movingCube.position.x > -270)
        movingCube.position.x -= moveDistance;
      if (camera.position.x > -150) {
        camera.position.x -= moveDistance * 0.6;
        if (camera.rotation.z > -5 * Math.PI / 180) {
          camera.rotation.z -= 0.2 * Math.PI / 180;
        }
      }
    }
    if (keyboard.pressed("right")) {
      if (movingCube.position.x < 270)
        movingCube.position.x += moveDistance;
      if (camera.position.x < 150) {
        camera.position.x += moveDistance * 0.6;
        if (camera.rotation.z < 5 * Math.PI / 180) {
          camera.rotation.z += 0.2 * Math.PI / 180;
        }
      }
    }
    if (keyboard.pressed("A")) {
      movingCube.rotation.y -= rotateAngle;
    }
    if (keyboard.pressed("D")) {
      movingCube.rotation.y += rotateAngle;
    }
    if (keyboard.pressed("up") || keyboard.pressed("W")) {
      movingCube.position.z -= moveDistance;
    }
    if (keyboard.pressed("down") || keyboard.pressed("S")) {
      movingCube.position.z += moveDistance;
    }
    
    var originPoint = movingCube.position.clone();
    for (var vertexIndex = 0; vertexIndex < movingCube.geometry.vertices.length; vertexIndex++) {
      // 顶点原始坐标
      var localVertex = movingCube.geometry.vertices[vertexIndex].clone();
      // 顶点经过变换后的坐标
      var globalVertex = localVertex.applyMatrix4(movingCube.matrix);
      var directionVector = globalVertex.sub(movingCube.position);
    
      var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
      var collisionResults = ray.intersectObjects(collideMeshList);
      if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
        crash = true;
        crashId = collisionResults[0].object.name;
        break;
      }
      crash = false;
    }
    if (crash) {
      movingCube.material.color.setHex(0x346386);
      console.log("Crash");
      if (crashId !== lastCrashId) {
        score -= 100;
        lastCrashId = crashId;
      }
    } else {
      movingCube.material.color.setHex(0x00ff00);
    }
    if (Math.random() < 0.03 && cubes.length < 30) {
      makeRandomCube();
    }
    for (i = 0; i < cubes.length; i++) {
      if (cubes[i].position.z > camera.position.z) {
        scene.remove(cubes[i]);
        cubes.splice(i, 1);
        collideMeshList.splice(i, 1);
      } else {
        cubes[i].position.z += 10;
      }
    }
  }
  
  function makeRandomCube() {
    var a = 50,
      b = getRandomInt(1, 3) * 50,
      c = 50;
    var geometry = new THREE.CubeGeometry(a, b, c);
    var material = new THREE.MeshBasicMaterial({
      color: Math.random() * 0xffffff
    });
  
    var object = new THREE.Mesh(geometry, material);
    var box = new THREE.BoxHelper(object);
  
    box.material.color.setHex(0xff0000);
  
    box.position.x = getRandomArbitrary(-250, 250);
    box.position.y = 1 + b / 2;
    box.position.z = getRandomArbitrary(-800, -1200);
    cubes.push(box);
    box.name = "box_" + id;
    id++;
    collideMeshList.push(box);
  
    scene.add(box);
    
  }

  // 返回一个介于min和max之间的随机数
  function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
  }

  // 返回一个介于min和max之间的整型随机数
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
</script>
</body>
</html>
